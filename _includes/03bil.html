<html>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<head>
	<title>Billiard</title>
	<style>
		body {
			font-size: 15px;
		}

		/* Define color variable */
		:root {
			--green-color: #6F777D;
		}

		.slider {
			-webkit-appearance: none;
			width: 80px;
			height: 6px;
			border-radius: 5px;
			background: #d3d3d3;
			outline: none;
			opacity: 0.7;
			-webkit-transition: .2s;
			transition: opacity .2s;
		}

		/* For WebKit browsers like Chrome and Safari */
		.slider::-webkit-slider-thumb {
			-webkit-appearance: none;
			width: 15px;
			height: 15px;
			border-radius: 50%;
			background: var(--green-color);
			cursor: pointer;
		}

		/* For Firefox */
		.slider::-moz-range-thumb {
			width: 15px;
			height: 15px;
			border-radius: 50%;
			background: var(--green-color);
			cursor: pointer;
		}
	</style>
</head>

<body>
	<button class="btn btn--primary btn--small" onclick="setupScene()">Restart</button>
	<button class="btn btn-outline-primary btn--small" onclick="resetSliderToMidValue()">Restitution</button>
	<input type="range" min="0" max="10" value="10" id="restitutionSlider" class="slider">
	<br>
	<canvas id="myCanvas" style="
				border: 2px solid;
				width: 100%;
				max-width=950px,
				max-height=600px,
				">
	</canvas>

	<!-- Include numeric.js from CDN -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/numeric/1.2.6/numeric.min.js"></script>

	<script>
		// Slider Helper -------------------------------------------------------

		function resetSliderToMidValue() {
			var slider = document.getElementById("restitutionSlider");
			var defaultValue = parseFloat(slider.getAttribute("value"));
			slider.value = defaultValue;
		}

		// Drawing functionality -------------------------------------------------------

		const canvas = document.getElementById("myCanvas");
		const context = canvas.getContext("2d");

		canvas.width = window.innerWidth - 25;
		canvas.height = Math.min(0.50 * canvas.width, window.innerHeight - 100);

		const rescaling = 2.0;
		const canvas_scale = Math.min(canvas.width, canvas.height) / rescaling;
		const sim_width = canvas.width / canvas_scale;
		const sim_height = canvas.height / canvas_scale;

		function cX(pos) {
			return pos.x * canvas_scale;
		}

		function cY(pos) {
			return canvas.height - pos.y * canvas_scale;
		}

		// Vector Math -------------------------------------------------------

		class Vector2 {
			constructor(x = 0.0, y = 0.0) {
				this.x = x;
				this.y = y;
			}

			set(v) {
				this.x = v.x; this.y = v.y;
			}

			clone() {
				return new Vector2(this.x, this.y);
			}

			add(v, s = 1.0) {
				this.x += v.x * s;
				this.y += v.y * s;
				return this;
			}

			addVectors(a, b) {
				this.x = a.x + b.x;
				this.y = a.y + b.y;
				return this;
			}

			subtract(v, s = 1.0) {
				this.x -= v.x * s;
				this.y -= v.y * s;
				return this;
			}

			subtractVectors(a, b) {
				this.x = a.x - b.x;
				this.y = a.y - b.y;
				return this;
			}

			length() {
				return Math.sqrt(this.x * this.x + this.y * this.y);
			}

			scale(s) {
				this.x *= s;
				this.y *= s;
			}

			dot(v) {
				return this.x * v.x + this.y * v.y;
			}
		}

		// Numerical Solver -------------------------------------------------------

		class NewtonSolver {
			constructor(context, residual, jacobian, tolerance = 1e-5, maxIterations = 20, regularization = 1e-3) {
				this.context = context;
				this.residualFunction = residual;
				this.jacobianFunction = jacobian;
				this.tolerance = tolerance;
				this.maxIterations = maxIterations;
				this.regularization = regularization
			}

			solve(initialGuess) {
				const startTime = performance.now();
				let x = initialGuess.slice(); // Make a copy of the initial guess
				const n = x.length;
				const regularizer = numeric.mul(this.regularization, numeric.identity(n));
				let iter = 0;

				for (let i = 0; i < this.maxIterations; i++) {
					iter += 1;

					const r = this.residualFunction(x);
					const J = numeric.add(this.jacobianFunction(x), regularizer);

					// Calculate the absolute norm of the residual vector
					const residualNorm = numeric.norm2(r);
					console.log("residual norm", residualNorm);
					context.font = '20px Arial'; // Set the font size and family
					this.context.fillText(residualNorm, 50, 50 + 20 * i);

					if (residualNorm < this.tolerance) {
						// The solution is accurate enough
						break;
					}

					// Update x using Newton's method for vectors
					const JInverse = numeric.inv(J);
					const update = numeric.dot(JInverse, r);
					// Update vector x
					const scaleFactor = -1.0;
					x = numeric.add(x, numeric.mul(update, scaleFactor));
				}

				// If maxIterations reached, return the latest approximation
				const elapsedTime = performance.now() - startTime;

				return [x, elapsedTime, iter];
			}
		}

		class ConstrainedSolver {
			constructor(
				context,
				residual,
				jacobian,
				constrained_indices,
				tolerance = 1e-5,
				maxIterations = 20,
				regularization = 1e-3,
			) {
				this.context = context;
				this.residualFunction = residual;
				this.jacobianFunction = jacobian;
				this.constrained_indices = constrained_indices;
				this.tolerance = tolerance;
				this.maxIterations = maxIterations;
				this.regularization = regularization;
				this.rho = 1.0;
			}

			project(x) {
				const indices = this.constrained_indices;
				x.set(indices, numeric.min(x.get(indices), 1e-2));
			}

			update_step_size(x, dx, alpha) {
				for (let i = 0; i < this.constrained_indices.length; i++) {
					const index = this.constrained_indices[i];
					const xi = x[index];
					const dxi = dx[index];
					if (dxi < 0) {
						alpha = Math.min(alpha, - xi / dxi)
					}
				}
				return alpha;
			}

			solve(initialGuess) {
				const startTime = performance.now();
				let x = initialGuess.slice(); // Make a copy of the initial guess
				const n = x.length;
				const regularizer = numeric.mul(this.regularization, numeric.identity(n));
				let iter = 0;

				for (let i = 0; i < this.maxIterations; i++) {
					iter += 1;

					const r = this.residualFunction(x);
					const J = numeric.add(this.jacobianFunction(x), regularizer);

					// Calculate the absolute norm of the residual vector
					const residualNorm = numeric.norm2(r);
					// console.log("residual norm", residualNorm);
					context.font = '20px Arial'; // Set the font size and family
					this.context.fillText(residualNorm, 50, 50 + 20 * i);

					if (residualNorm < this.tolerance) {
						// The solution is accurate enough
						break;
					}

					// Update x using Newton's method for vectors
					const JInverse = numeric.inv(J);
					const update = numeric.mul(-1.0, numeric.dot(JInverse, r));
					// console.log("update", update)
					// Update vector x
					const alpha = this.update_step_size(x, update, 1.0)
					console.log("alpha", alpha)
					x = numeric.add(x, numeric.mul(update, alpha));
					// x = numeric.add(x, numeric.mul(update, 0.5));
					// console.log("x", x)
				}

				// If maxIterations reached, return the latest approximation
				const elapsedTime = performance.now() - startTime;

				return [x, elapsedTime, iter];
			}
		}

		// Physics Scene -------------------------------------------------------

		class Ball {
			constructor(radius, mass, pos, vel) {
				this.radius = radius;
				this.mass = mass;
				this.pos = pos.clone();
				this.vel = vel.clone();
			}
			simulate(dt, gravity) {
				this.vel.add(gravity, dt);
				this.pos.add(this.vel, dt);
			}
		}

		var physicsScene =
		{
			gravity: new Vector2(0.0, 0.0),
			dt: 1.0 / 60.0,
			worldSize: new Vector2(sim_width, sim_height),
			paused: true,
			balls: [],
			restitution: 1.0
		};

		function setupScene() {
			physicsScene.balls = [];
			var numBalls = 20;

			for (i = 0; i < numBalls; i++) {

				var radius = 0.05 + Math.random() * 0.1;
				var mass = Math.PI * radius * radius;
				var pos = new Vector2(Math.random() * sim_width, Math.random() * sim_height);
				var vel = new Vector2(-1.0 + 2.0 * Math.random(), -1.0 + 2.0 * Math.random());

				physicsScene.balls.push(new Ball(radius, mass, pos, vel));
			}
		}

		// draw -------------------------------------------------------

		function draw() {
			context.clearRect(0, 0, canvas.width, canvas.height);

			// Declare green_color variable within the body
			const green_color = getComputedStyle(document.documentElement).getPropertyValue('--green-color');
			context.fillStyle = green_color;


			for (i = 0; i < physicsScene.balls.length; i++) {
				var ball = physicsScene.balls[i];
				context.beginPath();
				context.arc(
					cX(ball.pos), cY(ball.pos), canvas_scale * ball.radius, 0.0, 2.0 * Math.PI);
				context.closePath();
				context.fill();
			}


			// // Assuming that context is defined elsewhere in your code
			context.font = '20px Arial'; // Set the font size and family

			// Example usage:
			const residualFunction = x => [(x[0] + 3) ** 2 - 4, x[1] ** 2 - 9]; // Example: solving for [sqrt(4), sqrt(9)]
			const jacobianFunction = x => [[2 * (x[0] + 3), 0], [0, 2 * x[1]]];
			const constrained_indices = [0];
			const solver = new ConstrainedSolver(
				context,
				residualFunction,
				jacobianFunction,
				constrained_indices,
				tolerance = 1e-5,
				maxIterations = 20,
				regularization = 1e-3,
			);
			const [result, elapsedTime, iterations] = solver.solve([Math.random(), Math.random()]);

			// console.log("Approximate solution:", result);
			// console.log("Time taken:", elapsedTime, "milliseconds");
			// console.log("Iterations:", iterations);
			context.fillText(result[0], 300, 50);
			context.fillText(result[1], 300, 70);
		}


		// collision handling -------------------------------------------------------

		function handleBallCollision(ball1, ball2, restitution) {
			var dir = new Vector2();
			dir.subtractVectors(ball2.pos, ball1.pos);
			var d = dir.length();
			if (d == 0.0 || d > ball1.radius + ball2.radius)
				return;

			dir.scale(1.0 / d);

			var corr = (ball1.radius + ball2.radius - d) / 2.0;
			ball1.pos.add(dir, -corr);
			ball2.pos.add(dir, corr);

			var v1 = ball1.vel.dot(dir);
			var v2 = ball2.vel.dot(dir);

			var m1 = ball1.mass;
			var m2 = ball2.mass;

			var newV1 = (m1 * v1 + m2 * v2 - m2 * (v1 - v2) * restitution) / (m1 + m2);
			var newV2 = (m1 * v1 + m2 * v2 - m1 * (v2 - v1) * restitution) / (m1 + m2);

			ball1.vel.add(dir, newV1 - v1);
			ball2.vel.add(dir, newV2 - v2);
		}

		// ------------------------------------------------------

		function handleWallCollision(ball, worldSize) {
			if (ball.pos.x < ball.radius) {
				ball.pos.x = ball.radius;
				ball.vel.x = -ball.vel.x;
			}
			if (ball.pos.x > worldSize.x - ball.radius) {
				ball.pos.x = worldSize.x - ball.radius;
				ball.vel.x = -ball.vel.x;
			}
			if (ball.pos.y < ball.radius) {
				ball.pos.y = ball.radius;
				ball.vel.y = -ball.vel.y;
			}

			if (ball.pos.y > worldSize.y - ball.radius) {
				ball.pos.y = worldSize.y - ball.radius;
				ball.vel.y = -ball.vel.y;
			}
		}

		// simulation -------------------------------------------------------

		function simulate() {
			for (i = 0; i < physicsScene.balls.length; i++) {
				var ball1 = physicsScene.balls[i];
				ball1.simulate(physicsScene.dt, physicsScene.gravity);

				for (j = i + 1; j < physicsScene.balls.length; j++) {
					var ball2 = physicsScene.balls[j];
					handleBallCollision(ball1, ball2, physicsScene.restitution);
				}

				handleWallCollision(ball1, physicsScene.worldSize);
			}
		}

		function update() {
			simulate();
			draw();
			requestAnimationFrame(update);
		}

		setupScene();
		update();

		document.getElementById("restitutionSlider").oninput = function () {
			physicsScene.restitution = this.value / 10.0;
		}

	</script>
</body>

</html>